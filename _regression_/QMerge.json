{
    "combined_with_daveagp": [
        true,
        "package combined.daveagp;\nimport stdlibpack.*;\npublic class QMerge {\n   // ASSUMING a and b are sorted in increasing order, return a new queue\n   // consisting of the elements of both in combined increasing order\n   public static Queue<Integer> merge(Queue<Integer> a, Queue<Integer> b) {\n      Queue<Integer> result = new Queue<Integer>();\n   \n      // keep going as long as there are elements to merge\n      while ( !a.isEmpty() && !b.isEmpty() ) {\n         // take the smaller element from either a or b, move it to result\n         if (a.peek() < b.peek())\n            result.enqueue(a.dequeue());\n         else\n            result.enqueue(b.dequeue());         \n      }\n   \n      // if anything is left over once one queue is empty, move it into result\n      while (!a.isEmpty()) result.enqueue(a.dequeue());\n\n      while (!b.isEmpty()) result.enqueue(b.dequeue());\n\n      return result;\n   }\n   \n   // return a new queue consisting of the same elements in sorted order\n   public static Queue<Integer> mergeSort(Queue<Integer> input) {\n      if (input.size() == 1) {  // base case\n         Queue<Integer> result = new Queue<Integer>();\n         result.enqueue(input.peek());\n         return result;\n      }\n      else {\n         // move half the elements into a new queue\n         Queue<Integer> temp = new Queue<Integer>();\n\n         while (temp.size()*2 < input.size())\n            temp.enqueue(input.dequeue());\n\n         // sort both halves and merge\n         return  merge(mergeSort(input), mergeSort(temp))      ;\n      }\n   }\n   \n   // read all integers from input, sort them, and print them\n   public static void main(String[] args) {\n      Queue<Integer> data = new Queue<Integer>();\n      while (!StdIn.isEmpty())\n         data.enqueue(StdIn.readInt());\n      Queue<Integer> sortedData = mergeSort(data);\n      while (!sortedData.isEmpty())\n         StdOut.println(sortedData.dequeue());\n   }\n}\n",
        {
            "10": 8,
            "11": 9,
            "12": 10,
            "13": 11,
            "14": 12,
            "15": 13,
            "16": 14,
            "17": 15,
            "18": 16,
            "19": 17,
            "20": 18,
            "21": 19,
            "22": 20,
            "23": 21,
            "24": 22,
            "25": 23,
            "26": 24,
            "27": 25,
            "28": 26,
            "29": 27,
            "3": 1,
            "30": 28,
            "31": 29,
            "32": 30,
            "33": 31,
            "34": 32,
            "35": 33,
            "36": 34,
            "37": 35,
            "38": 36,
            "39": 37,
            "4": 2,
            "40": 38,
            "41": 39,
            "42": 40,
            "43": 41,
            "44": 42,
            "45": 43,
            "46": 44,
            "47": 45,
            "48": 46,
            "49": 47,
            "5": 3,
            "50": 48,
            "51": 49,
            "52": 50,
            "53": 51,
            "54": 52,
            "55": 53,
            "6": 4,
            "7": 5,
            "8": 6,
            "9": 7
        }
    ],
    "combined_with_initial": [
        false,
        "Line 8:\nmust not be empty"
    ],
    "combined_with_reference": [
        true,
        "package combined.reference;\nimport stdlibpack.*;\npublic class QMerge {\n   // ASSUMING a and b are sorted in increasing order, return a new queue\n   // consisting of the elements of both in combined increasing order\n   public static Queue<Integer> merge(Queue<Integer> a, Queue<Integer> b) {\n      Queue<Integer> result = new Queue<Integer>();\n   \n      // keep going as long as there are elements to merge\n      while ( !a.isEmpty() && !b.isEmpty() ) {\n         // take the smaller element from either a or b, move it to result\n         if (b.peek() < a.peek())\n            result.enqueue(b.dequeue());\n         else\n            result.enqueue(a.dequeue());\n      }\n   \n      // if anything is left over once one queue is empty, move it into result\n      while (!a.isEmpty())\n         result.enqueue(a.dequeue());\n      while (!b.isEmpty())\n         result.enqueue(b.dequeue());\n      return result;\n   }\n   \n   // return a new queue consisting of the same elements in sorted order\n   public static Queue<Integer> mergeSort(Queue<Integer> input) {\n      if (input.size() == 1) {  // base case\n         Queue<Integer> result = new Queue<Integer>();\n         result.enqueue(input.dequeue());\n         return result;\n      }\n      else {\n         // move half the elements into a new queue\n         int halfSize = input.size() / 2; \n         Queue<Integer> firstHalf = new Queue<Integer>();\n         for (int i=0; i<halfSize; i++) \n            firstHalf.enqueue(input.dequeue());\n         // sort both halves and merge\n         return  merge(mergeSort(firstHalf), mergeSort(input)) ;\n      }\n   }\n   \n   // read all integers from input, sort them, and print them\n   public static void main(String[] args) {\n      Queue<Integer> data = new Queue<Integer>();\n      while (!StdIn.isEmpty())\n         data.enqueue(StdIn.readInt());\n      Queue<Integer> sortedData = mergeSort(data);\n      while (!sortedData.isEmpty())\n         StdOut.println(sortedData.dequeue());\n   }\n}\n",
        {
            "10": 8,
            "11": 9,
            "12": 10,
            "13": 11,
            "14": 12,
            "15": 13,
            "16": 14,
            "17": 15,
            "18": 16,
            "19": 17,
            "20": 18,
            "21": 19,
            "22": 20,
            "23": 21,
            "24": 22,
            "25": 23,
            "26": 24,
            "27": 25,
            "28": 26,
            "29": 27,
            "3": 1,
            "30": 28,
            "31": 29,
            "32": 30,
            "33": 31,
            "34": 32,
            "35": 33,
            "36": 34,
            "37": 35,
            "38": 36,
            "39": 37,
            "4": 2,
            "40": 38,
            "41": 39,
            "42": 40,
            "43": 41,
            "44": 42,
            "45": 43,
            "46": 44,
            "47": 45,
            "48": 46,
            "49": 47,
            "5": 3,
            "50": 48,
            "51": 49,
            "52": 50,
            "53": 51,
            "54": 52,
            "6": 4,
            "7": 5,
            "8": 6,
            "9": 7
        }
    ],
    "daveagp": [
        " !a.isEmpty() && !b.isEmpty() ",
        "\n         if (a.peek() < b.peek())\n            result.enqueue(a.dequeue());\n         else\n            result.enqueue(b.dequeue());         \n",
        "\n      while (!a.isEmpty()) result.enqueue(a.dequeue());\n\n      while (!b.isEmpty()) result.enqueue(b.dequeue());\n\n",
        "\n         result.enqueue(input.peek());\n",
        "\n         Queue<Integer> temp = new Queue<Integer>();\n\n         while (temp.size()*2 < input.size())\n            temp.enqueue(input.dequeue());\n\n",
        " merge(mergeSort(input), mergeSort(temp))      "
    ],
    "initial_snippets": [
        "                              ",
        "\n\n\n\n\n",
        "\n\n\n\n\n",
        "\n\n",
        "\n\n\n\n\n",
        "                                               "
    ],
    "json_template": [
        "public class QMerge {\n   // ASSUMING a and b are sorted in increasing order, return a new queue\n   // consisting of the elements of both in combined increasing order\n   public static Queue<Integer> merge(Queue<Integer> a, Queue<Integer> b) {\n      Queue<Integer> result = new Queue<Integer>();\n   \n      // keep going as long as there are elements to merge\n      while (",
        "                              ",
        ") {\n         // take the smaller element from either a or b, move it to result",
        "\n\n\n\n\n",
        "      }\n   \n      // if anything is left over once one queue is empty, move it into result",
        "\n\n\n\n\n",
        "      return result;\n   }\n   \n   // return a new queue consisting of the same elements in sorted order\n   public static Queue<Integer> mergeSort(Queue<Integer> input) {\n      if (input.size() == 1) {  // base case\n         Queue<Integer> result = new Queue<Integer>();",
        "\n\n",
        "         return result;\n      }\n      else {\n         // move half the elements into a new queue",
        "\n\n\n\n\n",
        "         // sort both halves and merge\n         return ",
        "                                               ",
        ";\n      }\n   }\n   \n   // read all integers from input, sort them, and print them\n   public static void main(String[] args) {\n      Queue<Integer> data = new Queue<Integer>();\n      while (!StdIn.isEmpty())\n         data.enqueue(StdIn.readInt());\n      Queue<Integer> sortedData = mergeSort(data);\n      while (!sortedData.isEmpty())\n         StdOut.println(sortedData.dequeue());\n   }\n}"
    ],
    "reference_snippets": [
        " !a.isEmpty() && !b.isEmpty() ",
        "\n         if (b.peek() < a.peek())\n            result.enqueue(b.dequeue());\n         else\n            result.enqueue(a.dequeue());\n",
        "\n      while (!a.isEmpty())\n         result.enqueue(a.dequeue());\n      while (!b.isEmpty())\n         result.enqueue(b.dequeue());\n",
        "\n         result.enqueue(input.dequeue());\n",
        "\n         int halfSize = input.size() / 2; \n         Queue<Integer> firstHalf = new Queue<Integer>();\n         for (int i=0; i<halfSize; i++) \n            firstHalf.enqueue(input.dequeue());\n",
        " merge(mergeSort(firstHalf), mergeSort(input)) "
    ],
    "reference_solution": "package reference;\nimport stdlibpack.*;\npublic class QMerge {\n   // ASSUMING a and b are sorted in increasing order, return a new queue\n   // consisting of the elements of both in combined increasing order\n   public static Queue<Integer> merge(Queue<Integer> a, Queue<Integer> b) {\n      Queue<Integer> result = new Queue<Integer>();\n   \n      // keep going as long as there are elements to merge\n      while ( !a.isEmpty() && !b.isEmpty() ) {\n         // take the smaller element from either a or b, move it to result\n         if (b.peek() < a.peek())\n            result.enqueue(b.dequeue());\n         else\n            result.enqueue(a.dequeue());\n      }\n   \n      // if anything is left over once one queue is empty, move it into result\n      while (!a.isEmpty())\n         result.enqueue(a.dequeue());\n      while (!b.isEmpty())\n         result.enqueue(b.dequeue());\n      return result;\n   }\n   \n   // return a new queue consisting of the same elements in sorted order\n   public static Queue<Integer> mergeSort(Queue<Integer> input) {\n      if (input.size() == 1) {  // base case\n         Queue<Integer> result = new Queue<Integer>();\n         result.enqueue(input.dequeue());\n         return result;\n      }\n      else {\n         // move half the elements into a new queue\n         int halfSize = input.size() / 2; \n         Queue<Integer> firstHalf = new Queue<Integer>();\n         for (int i=0; i<halfSize; i++) \n            firstHalf.enqueue(input.dequeue());\n         // sort both halves and merge\n         return  merge(mergeSort(firstHalf), mergeSort(input)) ;\n      }\n   }\n   \n   // read all integers from input, sort them, and print them\n   public static void main(String[] args) {\n      Queue<Integer> data = new Queue<Integer>();\n      while (!StdIn.isEmpty())\n         data.enqueue(StdIn.readInt());\n      Queue<Integer> sortedData = mergeSort(data);\n      while (!sortedData.isEmpty())\n         StdOut.println(sortedData.dequeue());\n   }\n}\n"
}
